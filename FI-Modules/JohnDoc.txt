
beginDocumentation()
multidoc ///
 Node
  Key
   FI-Modules
  Headline
     Computing with finitely presented FI-modules
  Description
   Text
    {\em FI-Modules} is a package for computing with finitely presented FI-modules.
  Caveat
    This documentation is currently speculative.  It is a wish list for the future package.
 Node
  Key
   (FIMatrix, List, List, List)
   FIMatrix
  Headline
   Construction of an FI-matrix.  
  Usage
   FIMatrix(rows, matrix, cols)
  Inputs
   rows: A list of nonnegative integers giving the FI-objects that label the rows
   matrix: A list of lists of FI-Ring elements
   cols: A list of nonnegative integers giving the FI-objects that label the columns
  Outputs
   :
    An FI-matrix filled by the FI-ring elements given in \tt{matrix}.
  Description
   There is an important homogeneity constraint on inputs.  The (i,j) entry of the matrix 
   \tt{matrix} must be a linear combination of FI-morphisms from \tt{rows#i} to \tt{cols#j}.
   Such a linear combination is packaged as an \tt{FIRingElement}. 
    Here we show an example of multiplying two matrices.  Note that the \tt{cols} argument of
    the fist matrix matches the \tt{rows} argument of the second matrix.
   Example
    f = LinFI(QQ)
    m = matrix({1,2},{{2f_{1}-2f_{2},f_{1}+f_{2}+f_{3}},{f_{12}-f_{21},f_{12}+f_{23}+f_{31}}},{2,3})
    o = matrix({2,3},{{f_{12},f_{23}-f_{32}},{0,f_{1,2,3}+f_{2,3,1}+f_{3,1,2}}},{2,3})
    
   Output
             2                       3
    1 [ 2f_1 - 2f_2        2f_1 + 14f_2 - 10f_3     ]
    2 [ f_12 - f_21   2f_12 + 8f_23 + 2f_31 + 6f_32 ]
 
 Node
  Key
   (kernel,FIMatrix)
   FIMatrix
  Headline
   Generators for the kernel of an FI-matrix
  Usage
   FIKernel matrix
  Inputs
   matrix: An FI-matrix
  Outputs
   :
    An FI-matrix whose columns span the kernel of \tt{matrix}
  Description
   We interpret \tt{matrix} as describing a map between free FI-modules
       M(gens) <----- M(rels)
   where gens = {g_1, g_2, ..., g_t} is a list of natural numbers giving the FI-objects
   that label the rows of \tt{matrix} and rels = {r_1, r_2, ..., r_u} is a similar list
   for the columns of \tt{matrix}.  If the coefficient ring is Noetherian, then
   the kernel of this map is finitely generated by [CEFN], and so there exists a new free
   module M(syzs) so that the sequence
       M(gens) <----- M(rels) <----- M(syzs)
   is exact in the middle.  The new arrow is a map between free FI-modules, which is returned
   as an \tt{FIMatrix}.
   Example
    f = LinFI(QQ)
    m = matrix({1},{{f_2-f_1}},{2})
    FIKernel m
    
   Output
             2                 3
    2 [ f_12 + f_21   f_21 - f_31 + f_32 ]

 Node
  Key
   (hilbertSeries, FIMatrix)
   Divide
  Headline
   The Hilbert series of a finitely presented FI-module 
  Usage
   hilbertSeries matrix
  Inputs
   matrix: An FIMatrix giving a presentation
  Outputs
   :
    A rational function whose series expansion gives the dimension sequence of the 
    cokernel of \tt{matrix}
  Description
   The FIMatrix \tt{matrix} induces a map between free FI-modules
       M(gens) <----- M(rels)
   whose cokernel V is again an FI-module.  Equivalently, V is a finitely presented FI-module
   and \tt{matrix} is its presentation matrix.  By virtue of being an FI-module, V provides
   a vector space Vn for every FI-object n, and we package the dimensions of these spaces
   in a power series.
   
   Hilb(V) = (dim V_0) + (dim V_1)*T + (dim V_2)*T^2 + (dim V_3)*T^3 + ...
   
   By the eventual polynomiality theorem of CEF, this series may be rewritten as a rational
   function in the variable T.
   
   Since the Hilbert series is defined in terms of dimensions, this function requires that
   the coefficient ring be a field.
   
   Example
    f = LinFI(QQ)
    m = matrix({2},{{f_{12}+f_{23}+f_{31}}},{3})
    hilbertSeries m
    
   Output
    
       2    3     4     5
     2T  - T  - 2T  + 2T 
     -------------------
                 2
          (1 - T)


 Node
  Key
   (FICofree, List, FIMatrix)
   Divide
  Headline
   The structure maps of a cofree FI module
  Usage
   FICofree(degrees, matrix)
  Inputs
   degrees: A list of nonnegative integers specifying where to put the cogenerators
   matrix: An FIMatrix at which to evaluate the cofree
   
  Outputs
   :
    A matrix over the coefficient ring that describes the action of the cofree module
  Description
   The cofree FI-module cogenerated at the object d is defined as the linear dual of the
   free co-FI module generated at the object d^op.  Concretely, this amounts to writing
   the linear map "premultiplication by \tt{matrix}" in the monomial basis.
   
   Unlike free modules, cofree modules vanish apart from finitely many degrees.  For example,
   the cofree module with cogenerator in degree 5 has dimension sequence
   1, 5, 20, 60, 120, 120, 0, 0, 0, 0, 0, ...
   Each of these spaces comes with a monomial basis.  For example, the space at the object
   2 has a basis given by the 20 injections from {1,2} to {1,2,3,4,5}.  An FI morphism acts
   by the transpose of its precomposition map.  For example, the precomposition by the 
   inclusion {1} --> {1,2} induces a function on monomials FI(2,5) --> FI(1,5) given by
   restricting the injection to the subset {1}, and this function itself induces a 0-1 matrix
   whose transpose is the desired 5 x 20 matrix.
   
   If there are several cogenerators, then the list \tt{degrees} will be correspondingly
   longer, and the structure maps will be block sums of the maps already described.
   Example
    f = LinFI(QQ)
    m = matrix({1},{{f_{1}+3f_{3}}},{3})
    
   Output
    [1 1 1 1 1 1 0 0 3 0 3 0 0 0 3 0 3 0 0 0 3 0 3 0]
    [0 0 3 0 3 0 1 1 1 1 1 1 3 0 0 0 0 3 3 0 0 0 0 3]
    [3 0 0 0 0 3 3 0 0 0 0 3 1 1 1 1 1 1 0 3 0 3 0 0]
    [0 3 0 3 0 0 0 3 0 3 0 0 0 3 0 3 0 0 1 1 1 1 1 1]


 Node
  Key
   (FIStructureMap, FIMatrix, FIMatrix)
   Matrix
  Headline
   The structure maps of a finitely presented FI-module
  Usage
   FIStructureMap(presentation, matrix)
  Inputs
   presentation: An FIMatrix presenting some FI-module V as its cokernel
   matrix: An FIMatrix at which to evaluate V
   
  Outputs
   :
    A matrix over the coefficient ring giving the action of \tt{matrix} on the
    cokernel of \tt{presentation}
  Description
   An FI-module consists of a vector space for each natural number, and a structure map for
   each injection.  This function provides the structure maps of the FI-module with presentation
   matrix \tt{presentation}.  Taking \tt{matrix} to be a 1 x 1 FI-matrix containing a single
   monomial f : {1,...,m} --> {1,...,n}, this function returns the induced map
    Vf : Vm --> Vn
   as a matrix over the coefficient ring.  Larger FI-matrices extend this rule by linearity
   as well as by forming block matrices.
   Example
    f = LinFI(QQ)
    m = matrix({2},{{f_{12}-f{21}}},{2})
    o = matrix({4},{{f_{1234}+8f_{5432}}},{5})
    FIStructureMap(m, o)
    
   Output
    [1 0 0 0 0 0 0 0 0 8]
    [0 1 0 0 0 0 0 0 8 0]
    [0 0 1 0 0 0 8 0 0 0]
    [0 0 0 0 1 0 0 8 0 0]
    [0 0 0 0 0 9 0 0 0 0]
    [0 0 0 0 8 0 0 1 0 0]

 Node
  Key
   (Ext, ZZ, FIMatrix, FIMatrix)
   Module
  Headline
   Ext for FI-modules
  Usage
   Ext(i, first, second)
  Inputs
   i: A nonnegative integer giving cohomological degree
   first: An FIMatrix presenting some FI-module W as its cokernel
   second: An FIMatrix presenting some FI-module V as its cokernel
   
  Outputs
   :
    The module Ext^i(W,V)
  Description
   Given two finitely presented FI-modules V and W, this function returns Ext^i(V, W)
   considered as a module over the coefficient ring.  
  Example
    f = LinFI(QQ)
    m = matrix({1},{{f_{2}-f{1}}},{2})
    o = matrix({2},{{f_{12}+f_{21},f_{12}}},{2,3})
    Ext^1(m, o)
    
  Output
    QQ^1

///

TEST ///
    assert ( firstFunction 2 == "D'oh!" )
///

end--

You can write anything you want down here.  I like to keep examples
as I'm developing here.  Clean it up before submitting for
publication.  If you don't want to do that, you can omit the "end"
above.