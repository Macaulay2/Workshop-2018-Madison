{*
Description: Main method of the file is signSpace, which finds the
non-zero sign vectors of a given vector subspace. 

Authors: 
Jacob Zoromski (jzoromski@wisc.edu)
Polly Yu (pollyyu@math.wisc.edu)

Packages used: Polyhedra

Methods:

1) sgn
Description: Applies the sign function to each component of a vector
Input: v, a column vector (as a matrix or element of a free module)
Output: signVector, a list

2) signMatrices
Description:  Lists all diagonal nxn matrices with entries in {0,1,-1}
Input: n, an integer
Output: listMatrices, a list of matrices

3) signSpace
Description: Computes all non-zero sign vectors of a linear subspace given 
by the span of the columns of a matrix M
Input: M, a matrix
Output: signs, a list of sign vectors (as lists)

4) signClosure
Description: Computes the closure of the sign space, i.e. all sign vectors
of L plus all possible sign vectors made by replacing non-zero
entries of a vector in L with 0.
Input: L, a list of lists (the sign vectors)
Output: closureVectors, a list of lists (more sign vectors)

Example:
M = transpose matrix {{{1,1,0,-1},{0,2,1,-1}}
transpose matrix signSpace(M) = 
| -1 -1 -1 -1 -1 -1 -1 1  1  0  1  0  1  1  1  1  |
| -1 -1 -1 1  1  0  1  -1 -1 -1 0  1  1  1  -1 1  |
| -1 0  1  1  1  1  1  -1 -1 -1 -1 1  -1 0  -1 1  |
| 1  1  1  -1 0  1  1  -1 0  1  -1 -1 -1 -1 1  -1 |
*}


sgn = (v) -> (
    V := matrix v;
    signVector := new List;
    apply(numRows(V), i -> (
	if V_(i,0) > 0 then signVector = append(signVector, 1)
	else if V_(i,0) < 0 then signVector = append(signVector, -1)
	else signVector = append(signVector,0)
	       )
        );
    signVector
    )


signMatrices = (n) -> (
    minus1 := apply(n, i -> -1);
    plus1 = apply(n, i -> 1);
    listMatrices := toList(minus1..plus1);
    listMatrices  = apply(listMatrices, v -> diagonalMatrix v);
    listMatrices
    )


signSpace = (M) -> (
    signVectors := new List;
    listCones := new List;
    listRays := new List;
    interiorVectors := new List;
    listSignMatrices := signMatrices(numRows M);
    --Makes cones generated by M and all copies of M with rows 
    --multiplied by 1,-1, or 0
    listCones = apply(listSignMatrices, v -> (v * M));
    listCones = apply(listCones, A -> coneFromHData(A));
    listCones = unique(listCones);
    --Makes list of non-zero rays that generate the cones
    listRays = apply(listCones, i -> rays(i));
    listRays = apply(listRays, i -> if zero i then 0 else i);
    listRays = delete(0, listRays);
    --Finds interior vector of each cone by adding its rays
    interiorVectors = apply(listRays, C -> (
	    S := C_0;
	    apply(1..(numColumns(C)-1), j ->  (
	    	S = S + C_j)
	    );
	    S
	    )
	);
    --Finds sign vectors by applying the sign function to
    --M * an interior vector
    signVectors = apply(interiorVectors, v -> sgn(M * v));
    signVectors = unique(signVectors);
    signVectors
    )


signClosure = (L) -> (
    dimension := #(L#0);
    zeroes := toList(1..dimension);
    zeroes = apply(zeroes, i -> 0);
    ones := apply(zeroes, i -> 1);
    listMatrices := toList(zeroes..ones);
    listMatrices = apply(listMatrices, v -> diagonalMatrix v);
    closureVectors = apply(L, x -> (
	    X := transpose matrix {x};
	    closureX := apply(listMatrices, M -> M * X);
	    closureX
	    )
	);
    closureVectors = flatten(closureVectors);
    closureVectors = unique(closureVectors);
    --turns each vector from a matrix into a list
    closureVectors = apply(closureVectors, v -> apply(dimension, j -> v_(j,0)));	
    closureVectors
    )